---
layout: post
title: 'LRU Cache'
subtitle: LeetCode LRU Cache 문제 풀이
date: '2019-03-15 17:55:00-0400'
background: /img/posts/IMG_8904.JPG
categories: algorithm
published: true
---

Design and implement a data structure for [Least Recently Used (LRU) cache](https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU). It should support the following operations: `get` and `put`.

`get(key)` - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
`put(key, value)` - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.

**Follow up:**
Could you do both operations in **O(1)** time complexity?

**Example:**

```
LRUCache cache = new LRUCache( 2 /* capacity */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // returns 1
cache.put(3, 3);    // evicts key 2
cache.get(2);       // returns -1 (not found)
cache.put(4, 4);    // evicts key 1
cache.get(1);       // returns -1 (not found)
cache.get(3);       // returns 3
cache.get(4);       // returns 4
```

LRU Cache를 구현하는 문제이다. Least Recently Used cache의 약자이다. 제한된 용량의 캐시 영역에서 
최근에 억세스된(put/get 모두의 경우) data가 캐시 영역에 보존 되며. 억세스 빈도가 낮은 순서대로
캐시에 영역에서 제거된다. 이를 이용해서 자주 사용되는 데이터가 메모리 영역에 유지하여 불필요한 로딩 시간을
단축 할수 있게 된다. 실제로 안드로


<center>
  <img class="img" src="https://cdn-images-1.medium.com/max/1600/0*fOwBd3z0XtHh7WN1.png">
</center>




```c++
using namespace std;

struct node {
    
    int key;
    int data;
    node* prev;
    node* next;
    
    node(int key, int data) {
        this->key = key;
        this->data = data;
    }
    
};


class LRUCache {
public:
    
    int max_capacity;
    int current_capacity = 0;
    
    map<int,list<node>::iterator> mp;
    list<node> lt;
    
    LRUCache(int capacity) {
        this->max_capacity = capacity;
    }
    
    int get(int key) {
        
        if(mp.count(key) != 0){
            
            list<node>::iterator itor = mp[key];
            int return_val = itor->data;
            lt.splice(lt.begin(),lt,itor);
            mp[key] = lt.begin();
            
            return return_val;
            
        } else {
            return -1;
        }
    }
    
    void put(int key, int value) {

        if(mp.count(key) != 0){
            
            list<node>::iterator itor = mp[key];
            itor->data = value;
            lt.splice(lt.begin(),lt,itor);
            mp[key] = lt.begin();
            
        } else {
            
            if(lt.size() >= max_capacity) {
                mp.erase(lt.back().key);
                lt.pop_back();
            }
            
            lt.push_front(node(key,value));
            mp[key] = lt.begin();
        }

    }
};
```
